from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
from waitress import serve
from datetime import datetime
import pandas as pd

app = Flask(__name__)
CORS(app)

# Database Config
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///database.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

class CallLog(db.Model):
    __tablename__ = 'call_log'
    id = db.Column(db.Integer, primary_key=True)
    table_id = db.Column(db.Integer, nullable=False)
    event = db.Column(db.String(50), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.now, nullable=False)

# --- Analytics Logic ---
def calculate_analytics(logs_df):
    if logs_df.empty:
        return {
            'total': "0", 'open': "0", 'avg_resp': "0.0", 'avg_dlv': "0.0",
            'hourly': {i: 0 for i in range(24)}, 'closed': 0
        }

    logs_df['timestamp'] = pd.to_datetime(logs_df['timestamp'])
    
    total = 0
    closed_req = 0
    resp_times = []
    dlv_times = []
    hourly = {i: 0 for i in range(24)}
    
    # Process per table
    tables = logs_df.groupby('table_id')
    
    for tid, group in tables:
        events = group.sort_values('timestamp').to_dict('records')
        call_start = None
        
        for e in events:
            evt = e['event']
            ts = e['timestamp']
            
            if evt == "Customer_Called":
                total += 1
                call_start = ts
                h = ts.hour
                hourly[h] = hourly.get(h, 0) + 1
            elif evt == "Waiter_Responded" and call_start:
                diff = (ts - call_start).total_seconds() / 60
                resp_times.append(diff)
            elif (evt == "Food_Delivered" or "Bill" in evt) and call_start:
                diff = (ts - call_start).total_seconds() / 60
                dlv_times.append(diff)
                call_start = None
                closed_req += 1

    avg_resp = sum(resp_times)/len(resp_times) if resp_times else 0
    avg_dlv = sum(dlv_times)/len(dlv_times) if dlv_times else 0

    return {
        'total': str(total),
        'open': str(total - closed_req),
        'closed': closed_req,
        'avg_resp': f"{avg_resp:.1f}",
        'avg_dlv': f"{avg_dlv:.1f}",
        'hourly': hourly
    }

@app.route('/log', methods=['POST', 'GET'])
def log_data():
    data = request.get_json(silent=True) or request.args
    table_id = data.get('tableId') or data.get('table')
    event = data.get('event')

    if not table_id or not event:
        return jsonify({"status": "error"}), 400

    entry = CallLog(table_id=int(table_id), event=event)
    db.session.add(entry)
    db.session.commit()
    return jsonify({"status": "success"}), 200

@app.route('/data')
def get_data():
    try:
        logs_df = pd.read_sql_table('call_log', db.engine)
        analytics = calculate_analytics(logs_df)
    except Exception as e:
        print(e)
        logs_df = pd.DataFrame()
        analytics = calculate_analytics(logs_df)

    # Live Status Calculation
    live_status = []
    if not logs_df.empty:
        latest = logs_df.sort_values('timestamp').drop_duplicates(subset='table_id', keep='last')
        now = datetime.now()
        for _, r in latest.iterrows():
            last_event = r['event']
            # Determine if table is effectively idle
            status_display = last_event
            if last_event in ['Food_Delivered', 'Table_Closed ðŸ’° Bill']:
                status_display = "Idle"
            
            last_time = r['timestamp'].to_pydatetime()
            minutes_ago = int((now - last_time).total_seconds() / 60)
            
            live_status.append({
                'table_id': int(r['table_id']),
                'status': status_display,
                'minutes_ago': minutes_ago
            })
            
    return jsonify({'analytics': analytics, 'live_status': live_status})

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
    print("--- SERVER RUNNING ---")
    print("Use 'ipconfig' (Windows) to find your IPv4 Address.")
    serve(app, host='0.0.0.0', port=5000, threads=6)
